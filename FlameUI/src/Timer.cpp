#include "Timer.h"

#ifdef FL_PROFILING
#include "core_macros.h"
#include <fstream>

namespace FlameUI {
    std::vector<Timer::ScopeInfo> Timer::s_TimerScopeData;
    Timer::Timer(const std::string& scopeName)
        : m_ScopeName(scopeName)
    {
        m_Start = std::chrono::high_resolution_clock::now();
    }

    Timer::~Timer()
    {
        auto end = std::chrono::high_resolution_clock::now();
        float duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - m_Start).count() * 0.001f * 0.001f * 0.001f;
        s_TimerScopeData.emplace_back(m_ScopeName, duration);
    }

    void Timer::FlushTimings()
    {
        FL_ASSERT(s_TimerScopeData.size(), "No timer data!");
        std::ofstream stream(FL_PROJECT_DIR + std::string("FlameUI/logs/Timer.log"));
        FL_ASSERT(stream.is_open(), "Failed to create Timer.log!");
        stream << "##################################### Log file generated by Timer.h ####################################\n\n";

#ifdef FL_DEBUG
        stream << "Configuration: " << "Debug\n\n";
#elif defined(FL_RELEASE)
        stream << "Configuration: " << "Release\n\n";
#else
        stream << "Configuration: " << "Unknown\n\n";
#endif

        for (auto& timerData : s_TimerScopeData)
            stream << "process_name: " + timerData.ScopeName + "\nduration:\n\tseconds: " + std::to_string(timerData.Duration) + "\n\tmilliseconds: " + std::to_string(timerData.Duration * 1000.0f) + "\n\tmicroseconds: " + std::to_string(timerData.Duration * 1000.0f * 1000.0f) + "\n\n";
        stream.close();

        FL_LOG("All Timings are stored in the file \"{0}\"", FL_PROJECT_DIR + std::string("FlameUI/logs/Timer.log"));
    }
}
#endif